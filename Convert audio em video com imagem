#!/usr/bin/env python3
"""
Conversor Web para Ãudio - Text-to-Speech AvanÃ§ado
Extrai texto de pÃ¡ginas web e converte para Ã¡udio com mÃºltiplas opÃ§Ãµes
"""

import requests
import re
import os
import sys
import time
import argparse
from pathlib import Path
from urllib.parse import urlparse, urljoin
from dataclasses import dataclass
from typing import Optional, List, Dict
import logging

# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class AudioConfig:
    """ConfiguraÃ§Ãµes para conversÃ£o de Ã¡udio"""
    voice: str = "pt-BR"
    speed: float = 1.0
    pitch: int = 0
    volume: float = 0.9
    format: str = "mp3"
    quality: str = "high"

class WebToAudioConverter:
    """Conversor principal Web para Ãudio"""
    
    def __init__(self, config: AudioConfig = None):
        self.config = config or AudioConfig()
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # Verificar e inicializar TTS engines disponÃ­veis
        self.tts_engines = self._detect_tts_engines()
        logger.info(f"Engines TTS disponÃ­veis: {list(self.tts_engines.keys())}")
    
    def _detect_tts_engines(self) -> Dict[str, bool]:
        """Detecta quais engines TTS estÃ£o disponÃ­veis"""
        engines = {}
        
        # Google Text-to-Speech (gTTS)
        try:
            import gtts
            engines['gtts'] = True
            logger.info("âœ… gTTS (Google) disponÃ­vel")
        except ImportError:
            engines['gtts'] = False
            logger.warning("âŒ gTTS nÃ£o instalado: pip install gtts")
        
        # Pyttsx3 (offline)
        try:
            import pyttsx3
            engines['pyttsx3'] = True
            logger.info("âœ… pyttsx3 (offline) disponÃ­vel")
        except ImportError:
            engines['pyttsx3'] = False
            logger.warning("âŒ pyttsx3 nÃ£o instalado: pip install pyttsx3")
        
        # Azure Cognitive Services
        try:
            import azure.cognitiveservices.speech as speechsdk
            engines['azure'] = True
            logger.info("âœ… Azure Speech disponÃ­vel")
        except ImportError:
            engines['azure'] = False
            logger.warning("âŒ Azure Speech nÃ£o instalado: pip install azure-cognitiveservices-speech")
        
        # Edge TTS (Microsoft)
        try:
            import edge_tts
            engines['edge'] = True
            logger.info("âœ… Edge TTS disponÃ­vel")
        except ImportError:
            engines['edge'] = False
            logger.warning("âŒ Edge TTS nÃ£o instalado: pip install edge-tts")
        
        return engines
    
    def extract_text_from_url(self, url: str) -> str:
        """Extrai texto de uma URL usando mÃºltiplas estratÃ©gias"""
        logger.info(f"ğŸŒ Extraindo texto de: {url}")
        
        try:
            # EstratÃ©gia 1: BeautifulSoup (mais preciso)
            if self._is_package_available('bs4'):
                return self._extract_with_beautifulsoup(url)
            
            # EstratÃ©gia 2: Requests + Regex (fallback)
            return self._extract_with_regex(url)
            
        except Exception as e:
            logger.error(f"âŒ Erro na extraÃ§Ã£o: {e}")
            return ""
    
    def _is_package_available(self, package_name: str) -> bool:
        """Verifica se um pacote estÃ¡ disponÃ­vel"""
        try:
            __import__(package_name)
            return True
        except ImportError:
            return False
    
    def _extract_with_beautifulsoup(self, url: str) -> str:
        """Extrai texto usando BeautifulSoup (mais preciso)"""
        try:
            from bs4 import BeautifulSoup
            
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Remover elementos desnecessÃ¡rios
            for element in soup(["script", "style", "nav", "header", "footer", "aside"]):
                element.decompose()
            
            # Extrair texto do conteÃºdo principal
            main_content = (
                soup.find('main') or 
                soup.find('article') or 
                soup.find('div', class_=re.compile(r'content|article|post')) or
                soup.find('body')
            )
            
            if main_content:
                text = main_content.get_text(separator=' ', strip=True)
            else:
                text = soup.get_text(separator=' ', strip=True)
            
            # Limpar e formatar texto
            text = self._clean_text(text)
            logger.info(f"âœ… Texto extraÃ­do: {len(text)} caracteres")
            return text
            
        except ImportError:
            logger.warning("âŒ BeautifulSoup nÃ£o disponÃ­vel: pip install beautifulsoup4")
            return self._extract_with_regex(url)
        except Exception as e:
            logger.error(f"âŒ Erro no BeautifulSoup: {e}")
            return self._extract_with_regex(url)
    
    def _extract_with_regex(self, url: str) -> str:
        """Extrai texto usando regex (fallback bÃ¡sico)"""
        try:
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            html = response.text
            
            # Remover tags HTML
            text = re.sub(r'<script.*?</script>', '', html, flags=re.DOTALL | re.IGNORECASE)
            text = re.sub(r'<style.*?</style>', '', text, flags=re.DOTALL | re.IGNORECASE)
            text = re.sub(r'<[^>]+>', '', text)
            
            # Limpar texto
            text = self._clean_text(text)
            logger.info(f"âœ… Texto extraÃ­do (regex): {len(text)} caracteres")
            return text
            
        except Exception as e:
            logger.error(f"âŒ Erro na extraÃ§Ã£o com regex: {e}")
            return ""
    
    def _clean_text(self, text: str) -> str:
        """Limpa e formata o texto extraÃ­do"""
        if not text:
            return ""
        
        # Remover mÃºltiplos espaÃ§os em branco
        text = re.sub(r'\s+', ' ', text)
        
        # Remover caracteres especiais problemÃ¡ticos
        text = re.sub(r'[^\w\s\.,!?;:()\-Ã¡Ã©Ã­Ã³ÃºÃ¢ÃªÃ®Ã´Ã»Ã Ã¨Ã¬Ã²Ã¹Ã£ÃµÃ§ÃÃ‰ÃÃ“ÃšÃ‚ÃŠÃÃ”Ã›Ã€ÃˆÃŒÃ’Ã™ÃƒÃ•Ã‡]', '', text)
        
        # Limpar inÃ­cio e fim
        text = text.strip()
        
        return text
    
    def split_text_into_chunks(self, text: str, max_chars: int = 5000) -> List[str]:
        """Divide texto em chunks para evitar limites de TTS"""
        if len(text) <= max_chars:
            return [text]
        
        chunks = []
        sentences = re.split(r'[.!?]+', text)
        current_chunk = ""
        
        for sentence in sentences:
            sentence = sentence.strip()
            if not sentence:
                continue
                
            if len(current_chunk) + len(sentence) <= max_chars:
                current_chunk += sentence + ". "
            else:
                if current_chunk:
                    chunks.append(current_chunk.strip())
                current_chunk = sentence + ". "
        
        if current_chunk:
            chunks.append(current_chunk.strip())
        
        logger.info(f"ğŸ“ Texto dividido em {len(chunks)} partes")
        return chunks
    
    def text_to_speech_gtts(self, text: str, output_file: str) -> bool:
        """Converte texto para Ã¡udio usando Google TTS"""
        try:
            from gtts import gTTS
            import pygame
            
            logger.info("ğŸ”Š Convertendo com Google TTS...")
            
            tts = gTTS(
                text=text,
                lang='pt-br' if self.config.voice == 'pt-BR' else 'en',
                slow=False if self.config.speed >= 1.0 else True
            )
            
            tts.save(output_file)
            logger.info(f"âœ… Ãudio salvo: {output_file}")
            return True
            
        except ImportError:
            logger.error("âŒ gTTS nÃ£o instalado: pip install gtts pygame")
            return False
        except Exception as e:
            logger.error(f"âŒ Erro no gTTS: {e}")
            return False
    
    def text_to_speech_pyttsx3(self, text: str, output_file: str) -> bool:
        """Converte texto para Ã¡udio usando pyttsx3 (offline)"""
        try:
            import pyttsx3
            
            logger.info("ğŸ”Š Convertendo com pyttsx3 (offline)...")
            
            engine = pyttsx3.init()
            
            # Configurar voz
            voices = engine.getProperty('voices')
            for voice in voices:
                if 'brazil' in voice.name.lower() or 'portuguese' in voice.name.lower():
                    engine.setProperty('voice', voice.id)
                    break
            
            # Configurar velocidade e volume
            engine.setProperty('rate', int(200 * self.config.speed))
            engine.setProperty('volume', self.config.volume)
            
            # Salvar arquivo
            engine.save_to_file(text, output_file)
            engine.runAndWait()
            
            logger.info(f"âœ… Ãudio salvo: {output_file}")
            return True
            
        except ImportError:
            logger.error("âŒ pyttsx3 nÃ£o instalado: pip install pyttsx3")
            return False
        except Exception as e:
            logger.error(f"âŒ Erro no pyttsx3: {e}")
            return False
    
    def text_to_speech_edge(self, text: str, output_file: str) -> bool:
        """Converte texto para Ã¡udio usando Edge TTS"""
        try:
            import asyncio
            import edge_tts
            
            logger.info("ğŸ”Š Convertendo com Edge TTS...")
            
            async def _convert():
                voice = "pt-BR-FranciscaNeural"  # Voz feminina brasileira
                communicate = edge_tts.Communicate(text, voice)
                await communicate.save(output_file)
            
            asyncio.run(_convert())
            logger.info(f"âœ… Ãudio salvo: {output_file}")
            return True
            
        except ImportError:
            logger.error("âŒ Edge TTS nÃ£o instalado: pip install edge-tts")
            return False
        except Exception as e:
            logger.error(f"âŒ Erro no Edge TTS: {e}")
            return False
    
    def convert_url_to_audio(self, url: str, output_dir: str = "audio_output", 
                           engine: str = "auto") -> List[str]:
        """Processo completo: URL â†’ Texto â†’ Ãudio"""
        logger.info(f"ğŸš€ Iniciando conversÃ£o de {url}")
        
        # Criar diretÃ³rio de saÃ­da
        Path(output_dir).mkdir(exist_ok=True)
        
        # Extrair texto
        text = self.extract_text_from_url(url)
        if not text:
            logger.error("âŒ Nenhum texto extraÃ­do")
            return []
        
        # Salvar texto extraÃ­do
        domain = urlparse(url).netloc.replace('.', '_')
        text_file = Path(output_dir) / f"{domain}_texto.txt"
        with open(text_file, 'w', encoding='utf-8') as f:
            f.write(text)
        logger.info(f"ğŸ“„ Texto salvo em: {text_file}")
        
        # Dividir em chunks
        chunks = self.split_text_into_chunks(text)
        
        # Escolher engine TTS
        if engine == "auto":
            if self.tts_engines.get('edge'):
                engine = 'edge'
            elif self.tts_engines.get('gtts'):
                engine = 'gtts'
            elif self.tts_engines.get('pyttsx3'):
                engine = 'pyttsx3'
            else:
                logger.error("âŒ Nenhum engine TTS disponÃ­vel")
                return []
        
        # Converter chunks para Ã¡udio
        audio_files = []
        for i, chunk in enumerate(chunks, 1):
            output_file = Path(output_dir) / f"{domain}_part_{i:02d}.mp3"
            
            success = False
            if engine == 'gtts':
                success = self.text_to_speech_gtts(chunk, str(output_file))
            elif engine == 'pyttsx3':
                success = self.text_to_speech_pyttsx3(chunk, str(output_file))
            elif engine == 'edge':
                success = self.text_to_speech_edge(chunk, str(output_file))
            
            if success:
                audio_files.append(str(output_file))
            
            # Pausa entre conversÃµes
            time.sleep(1)
        
        logger.info(f"ğŸ‰ ConversÃ£o concluÃ­da! {len(audio_files)} arquivos gerados")
        return audio_files
    
    def play_audio(self, audio_file: str):
        """Reproduz arquivo de Ã¡udio"""
        try:
            import pygame
            pygame.mixer.init()
            pygame.mixer.music.load(audio_file)
            pygame.mixer.music.play()
            
            logger.info(f"ğŸ”Š Reproduzindo: {audio_file}")
            logger.info("Pressione Enter para parar...")
            
            while pygame.mixer.music.get_busy():
                if input() == "":
                    pygame.mixer.music.stop()
                    break
                    
        except ImportError:
            logger.error("âŒ pygame nÃ£o instalado: pip install pygame")
        except Exception as e:
            logger.error(f"âŒ Erro na reproduÃ§Ã£o: {e}")

def install_dependencies():
    """Instala dependÃªncias automaticamente"""
    packages = [
        'requests',
        'beautifulsoup4',
        'gtts',
        'pyttsx3',
        'edge-tts',
        'pygame'
    ]
    
    import subprocess
    import sys
    
    print("ğŸ“¦ Instalando dependÃªncias...")
    for package in packages:
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])
        except subprocess.CalledProcessError:
            print(f"âš ï¸ Falha ao instalar {package}")
    print("âœ… InstalaÃ§Ã£o concluÃ­da!")

def main():
    """FunÃ§Ã£o principal com interface de linha de comando"""
    parser = argparse.ArgumentParser(description="Conversor Web para Ãudio")
    parser.add_argument("url", help="URL da pÃ¡gina para converter")
    parser.add_argument("--output", "-o", default="audio_output", help="DiretÃ³rio de saÃ­da")
    parser.add_argument("--engine", "-e", choices=['gtts', 'pyttsx3', 'edge', 'auto'], 
                       default='auto', help="Engine TTS a usar")
    parser.add_argument("--speed", "-s", type=float, default=1.0, help="Velocidade da fala")
    parser.add_argument("--play", "-p", action='store_true', help="Reproduzir apÃ³s converter")
    parser.add_argument("--install", action='store_true', help="Instalar dependÃªncias")
    
    args = parser.parse_args()
    
    if args.install:
        install_dependencies()
        return
    
    # Configurar conversor
    config = AudioConfig(speed=args.speed)
    converter = WebToAudioConverter(config)
    
    # Converter
    audio_files = converter.convert_url_to_audio(args.url, args.output, args.engine)
    
    if not audio_files:
        print("âŒ Nenhum arquivo de Ã¡udio gerado")
        return
    
    print(f"\nğŸ‰ ConversÃ£o concluÃ­da!")
    print(f"ğŸ“ Arquivos salvos em: {args.output}")
    for file in audio_files:
        print(f"   ğŸ”Š {file}")
    
    # Reproduzir se solicitado
    if args.play and audio_files:
        for audio_file in audio_files:
            converter.play_audio(audio_file)

# ===== EXEMPLO DE USO INTERATIVO =====
def interactive_mode():
    """Modo interativo para facilitar o uso"""
    print("ğŸ™ï¸ Conversor Web para Ãudio - Modo Interativo")
    print("=" * 50)
    
    # URL
    url = input("ğŸŒ Digite a URL da pÃ¡gina: ").strip()
    if not url:
        print("âŒ URL obrigatÃ³ria")
        return
    
    # Engine
    print("\nğŸ”§ Engines TTS disponÃ­veis:")
    print("1. Auto (recomendado)")
    print("2. Google TTS (online)")
    print("3. Edge TTS (online, melhor qualidade)")
    print("4. pyttsx3 (offline)")
    
    engine_choice = input("Escolha (1-4): ").strip()
    engine_map = {'1': 'auto', '2': 'gtts', '3': 'edge', '4': 'pyttsx3'}
    engine = engine_map.get(engine_choice, 'auto')
    
    # ConfiguraÃ§Ãµes
    speed = input("ğŸƒ Velocidade da fala (0.5-2.0, padrÃ£o 1.0): ").strip()
    try:
        speed = float(speed) if speed else 1.0
    except ValueError:
        speed = 1.0
    
    # Converter
    config = AudioConfig(speed=speed)
    converter = WebToAudioConverter(config)
    
    print(f"\nğŸš€ Convertendo {url}...")
    audio_files = converter.convert_url_to_audio(url, engine=engine)
    
    if audio_files:
        print(f"\nâœ… Sucesso! {len(audio_files)} arquivos gerados:")
        for file in audio_files:
            print(f"   ğŸ”Š {file}")
        
        if input("\nğŸ”Š Reproduzir agora? (s/N): ").lower().startswith('s'):
            for audio_file in audio_files:
                converter.play_audio(audio_file)
    else:
        print("âŒ Falha na conversÃ£o")

if __name__ == "__main__":
    if len(sys.argv) == 1:
        # Modo interativo se nÃ£o houver argumentos
        interactive_mode()
    else:
        # Modo linha de comando
        main()

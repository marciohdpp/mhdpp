#!/usr/bin/env python3
"""
Conversor Web para √Åudio - Text-to-Speech Avan√ßado
Extrai texto de p√°ginas web e converte para √°udio com m√∫ltiplas op√ß√µes
"""

import requests
import re
import os
import sys
import time
import argparse
from pathlib import Path
from urllib.parse import urlparse, urljoin
from dataclasses import dataclass
from typing import Optional, List, Dict
import logging

# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class AudioConfig:
    """Configura√ß√µes para convers√£o de √°udio"""
    voice: str = "pt-BR"
    speed: float = 1.0
    pitch: int = 0
    volume: float = 0.9
    format: str = "mp3"
    quality: str = "high"

class WebToAudioConverter:
    """Conversor principal Web para √Åudio"""
    
    def __init__(self, config: AudioConfig = None):
        self.config = config or AudioConfig()
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # Verificar e inicializar TTS engines dispon√≠veis
        self.tts_engines = self._detect_tts_engines()
        logger.info(f"Engines TTS dispon√≠veis: {list(self.tts_engines.keys())}")
    
    def _detect_tts_engines(self) -> Dict[str, bool]:
        """Detecta quais engines TTS est√£o dispon√≠veis"""
        engines = {}
        
        # Google Text-to-Speech (gTTS)
        try:
            import gtts
            engines['gtts'] = True
            logger.info("‚úÖ gTTS (Google) dispon√≠vel")
        except ImportError:
            engines['gtts'] = False
            logger.warning("‚ùå gTTS n√£o instalado: pip install gtts")
        
        # Pyttsx3 (offline)
        try:
            import pyttsx3
            engines['pyttsx3'] = True
            logger.info("‚úÖ pyttsx3 (offline) dispon√≠vel")
        except ImportError:
            engines['pyttsx3'] = False
            logger.warning("‚ùå pyttsx3 n√£o instalado: pip install pyttsx3")
        
        # Azure Cognitive Services
        try:
            import azure.cognitiveservices.speech as speechsdk
            engines['azure'] = True
            logger.info("‚úÖ Azure Speech dispon√≠vel")
        except ImportError:
            engines['azure'] = False
            logger.warning("‚ùå Azure Speech n√£o instalado: pip install azure-cognitiveservices-speech")
        
        # Edge TTS (Microsoft)
        try:
            import edge_tts
            engines['edge'] = True
            logger.info("‚úÖ Edge TTS dispon√≠vel")
        except ImportError:
            engines['edge'] = False
            logger.warning("‚ùå Edge TTS n√£o instalado: pip install edge-tts")
        
        return engines
    
    def extract_text_from_url(self, url: str) -> str:
        """Extrai texto de uma URL usando m√∫ltiplas estrat√©gias"""
        logger.info(f"üåê Extraindo texto de: {url}")
        
        try:
            # Estrat√©gia 1: BeautifulSoup (mais preciso)
            if self._is_package_available('bs4'):
                return self._extract_with_beautifulsoup(url)
            
            # Estrat√©gia 2: Requests + Regex (fallback)
            return self._extract_with_regex(url)
            
        except Exception as e:
            logger.error(f"‚ùå Erro na extra√ß√£o: {e}")
            return ""
    
    def _is_package_available(self, package_name: str) -> bool:
        """Verifica se um pacote est√° dispon√≠vel"""
        try:
            __import__(package_name)
            return True
        except ImportError:
            return False
    
    def _extract_with_beautifulsoup(self, url: str) -> str:
        """Extrai texto usando BeautifulSoup (mais preciso)"""
        try:
            from bs4 import BeautifulSoup
            
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Remover elementos desnecess√°rios
            for element in soup(["script", "style", "nav", "header", "footer", "aside"]):
                element.decompose()
            
            # Extrair texto do conte√∫do principal
            main_content = (
                soup.find('main') or 
                soup.find('article') or 
                soup.find('div', class_=re.compile(r'content|article|post')) or
                soup.find('body')
            )
            
            if main_content:
                text = main_content.get_text(separator=' ', strip=True)
            else:
                text = soup.get_text(separator=' ', strip=True)
            
            # Limpar e formatar texto
            text = self._clean_text(text)
            logger.info(f"‚úÖ Texto extra√≠do: {len(text)} caracteres")
            return text
            
        except ImportError:
            logger.warning("‚ùå BeautifulSoup n√£o dispon√≠vel: pip install beautifulsoup4")
            return self._extract_with_regex(url)
        except Exception as e:
            logger.error(f"‚ùå Erro no BeautifulSoup: {e}")
            return self._extract_with_regex(url)
    
    def _extract_with_regex(self, url: str) -> str:
        """Extrai texto usando regex (fallback b√°sico)"""
        try:
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            html = response.text
            
            # Remover tags HTML
            text = re.sub(r'<script.*?</script>', '', html, flags=re.DOTALL | re.IGNORECASE)
            text = re.sub(r'<style.*?</style>', '', text, flags=re.DOTALL | re.IGNORECASE)
            text = re.sub(r'<[^>]+>', '', text)
            
            # Limpar texto
            text = self._clean_text(text)
            logger.info(f"‚úÖ Texto extra√≠do (regex): {len(text)} caracteres")
            return text
            
        except Exception as e:
            logger.error(f"‚ùå Erro na extra√ß√£o com regex: {e}")
            return ""
    
    def _clean_text(self, text: str) -> str:
        """Limpa e formata o texto extra√≠do"""
        if not text:
            return ""
        
        # Remover m√∫ltiplos espa√ßos em branco
        text = re.sub(r'\s+', ' ', text)
        
        # Remover caracteres especiais problem√°ticos
        text = re.sub(r'[^\w\s\.,!?;:()\-√°√©√≠√≥√∫√¢√™√Æ√¥√ª√†√®√¨√≤√π√£√µ√ß√Å√â√ç√ì√ö√Ç√ä√é√î√õ√Ä√à√å√í√ô√É√ï√á]', '', text)
        
        # Limpar in√≠cio e fim
        text = text.strip()
        
        return text
    
    def split_text_into_chunks(self, text: str, max_chars: int = 5000) -> List[str]:
        """Divide texto em chunks para evitar limites de TTS"""
        if len(text) <= max_chars:
            return [text]
        
        chunks = []
        sentences = re.split(r'[.!?]+', text)
        current_chunk = ""
        
        for sentence in sentences:
            sentence = sentence.strip()
            if not sentence:
                continue
                
            if len(current_chunk) + len(sentence) <= max_chars:
                current_chunk += sentence + ". "
            else:
                if current_chunk:
                    chunks.append(current_chunk.strip())
                current_chunk = sentence + ". "
        
        if current_chunk:
            chunks.append(current_chunk.strip())
        
        logger.info(f"üìù Texto dividido em {len(chunks)} partes")
        return chunks
    
    def text_to_speech_gtts(self, text: str, output_file: str) -> bool:
        """Converte texto para √°udio usando Google TTS"""
        try:
            from gtts import gTTS
            import pygame
            
            logger.info("üîä Convertendo com Google TTS...")
            
            tts = gTTS(
                text=text,
                lang='pt-br' if self.config.voice == 'pt-BR' else 'en',
                slow=False if self.config.speed >= 1.0 else True
            )
            
            tts.save(output_file)
            logger.info(f"‚úÖ √Åudio salvo: {output_file}")
            return True
            
        except ImportError:
            logger.error("‚ùå gTTS n√£o instalado: pip install gtts pygame")
            return False
        except Exception as e:
            logger.error(f"‚ùå Erro no gTTS: {e}")
            return False
    
    def text_to_speech_pyttsx3(self, text: str, output_file: str) -> bool:
        """Converte texto para √°udio usando pyttsx3 (offline)"""
        try:
            import pyttsx3
            
            logger.info("üîä Convertendo com pyttsx3 (offline)...")
            
            engine = pyttsx3.init()
            
            # Configurar voz
            voices = engine.getProperty('voices')
            for voice in voices:
                if 'brazil' in voice.name.lower() or 'portuguese' in voice.name.lower():
                    engine.setProperty('voice', voice.id)
                    break
            
            # Configurar velocidade e volume
            engine.setProperty('rate', int(200 * self.config.speed))
            engine.setProperty('volume', self.config.volume)
            
            # Salvar arquivo
            engine.save_to_file(text, output_file)
            engine.runAndWait()
            
            logger.info(f"‚úÖ √Åudio salvo: {output_file}")
            return True
            
        except ImportError:
            logger.error("‚ùå pyttsx3 n√£o instalado: pip install pyttsx3")
            return False
        except Exception as e:
            logger.error(f"‚ùå Erro no pyttsx3: {e}")
            return False
    
    def text_to_speech_edge(self, text: str, output_file: str) -> bool:
        """Converte texto para √°udio usando Edge TTS"""
        try:
            import asyncio
            import edge_tts
            
            logger.info("üîä Convertendo com Edge TTS...")
            
            async def _convert():
                voice = "pt-BR-FranciscaNeural"  # Voz feminina brasileira
                communicate = edge_tts.Communicate(text, voice)
                await communicate.save(output_file)
            
            asyncio.run(_convert())
            logger.info(f"‚úÖ √Åudio salvo: {output_file}")
            return True
            
        except ImportError:
            logger.error("‚ùå Edge TTS n√£o instalado: pip install edge-tts")
            return False
        except Exception as e:
            logger.error(f"‚ùå Erro no Edge TTS: {e}")
            return False
    
    def convert_url_to_audio(self, url: str, output_dir: str = "audio_output", 
                           engine: str = "auto") -> List[str]:
        """Processo completo: URL ‚Üí Texto ‚Üí √Åudio"""
        logger.info(f"üöÄ Iniciando convers√£o de {url}")
        
        # Criar diret√≥rio de sa√≠da
        Path(output_dir).mkdir(exist_ok=True)
        
        # Extrair texto
        text = self.extract_text_from_url(url)
        if not text:
            logger.error("‚ùå Nenhum texto extra√≠do")
            return []
        
        # Salvar texto extra√≠do
        domain = urlparse(url).netloc.replace('.', '_')
        text_file = Path(output_dir) / f"{domain}_texto.txt"
        with open(text_file, 'w', encoding='utf-8') as f:
            f.write(text)
        logger.info(f"üìÑ Texto salvo em: {text_file}")
        
        # Dividir em chunks
        chunks = self.split_text_into_chunks(text)
        
        # Escolher engine TTS
        if engine == "auto":
            if self.tts_engines.get('edge'):
                engine = 'edge'
            elif self.tts_engines.get('gtts'):
                engine = 'gtts'
            elif self.tts_engines.get('pyttsx3'):
                engine = 'pyttsx3'
            else:
                logger.error("‚ùå Nenhum engine TTS dispon√≠vel")
                return []
        
        # Converter chunks para √°udio
        audio_files = []
        for i, chunk in enumerate(chunks, 1):
            output_file = Path(output_dir) / f"{domain}_part_{i:02d}.mp3"
            
            success = False
            if engine == 'gtts':
                success = self.text_to_speech_gtts(chunk, str(output_file))
            elif engine == 'pyttsx3':
                success = self.text_to_speech_pyttsx3(chunk, str(output_file))
            elif engine == 'edge':
                success = self.text_to_speech_edge(chunk, str(output_file))
            
            if success:
                audio_files.append(str(output_file))
            
            # Pausa entre convers√µes
            time.sleep(1)
        
        logger.info(f"üéâ Convers√£o conclu√≠da! {len(audio_files)} arquivos gerados")
        return audio_files
    
    def play_audio(self, audio_file: str):
        """Reproduz arquivo de √°udio"""
        try:
            import pygame
            pygame.mixer.init()
            pygame.mixer.music.load(audio_file)
            pygame.mixer.music.play()
            
            logger.info(f"üîä Reproduzindo: {audio_file}")
            logger.info("Pressione Enter para parar...")
            
            while pygame.mixer.music.get_busy():
                if input() == "":
                    pygame.mixer.music.stop()
                    break
                    
        except ImportError:
            logger.error("‚ùå pygame n√£o instalado: pip install pygame")
        except Exception as e:
            logger.error(f"‚ùå Erro na reprodu√ß√£o: {e}")

def install_dependencies():
    """Instala depend√™ncias automaticamente"""
    packages = [
        'requests',
        'beautifulsoup4',
        'gtts',
        'pyttsx3',
        'edge-tts',
        'pygame'
    ]
    
    import subprocess
    import sys
    
    print("üì¶ Instalando depend√™ncias...")
    for package in packages:
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])
        except subprocess.CalledProcessError:
            print(f"‚ö†Ô∏è Falha ao instalar {package}")
    print("‚úÖ Instala√ß√£o conclu√≠da!")

def main():
    """Fun√ß√£o principal com interface de linha de comando"""
    parser = argparse.ArgumentParser(description="Conversor Web para √Åudio")
    parser.add_argument("url", help="URL da p√°gina para converter")
    parser.add_argument("--output", "-o", default="audio_output", help="Diret√≥rio de sa√≠da")
    parser.add_argument("--engine", "-e", choices=['gtts', 'pyttsx3', 'edge', 'auto'], 
                       default='auto', help="Engine TTS a usar")
    parser.add_argument("--speed", "-s", type=float, default=1.0, help="Velocidade da fala")
    parser.add_argument("--play", "-p", action='store_true', help="Reproduzir ap√≥s converter")
    parser.add_argument("--install", action='store_true', help="Instalar depend√™ncias")
    
    args = parser.parse_args()
    
    if args.install:
        install_dependencies()
        return
    
    # Configurar conversor
    config = AudioConfig(speed=args.speed)
    converter = WebToAudioConverter(config)
    
    # Converter
    audio_files = converter.convert_url_to_audio(args.url, args.output, args.engine)
    
    if not audio_files:
        print("‚ùå Nenhum arquivo de √°udio gerado")
        return
    
    print(f"\nüéâ Convers√£o conclu√≠da!")
    print(f"üìÅ Arquivos salvos em: {args.output}")
    for file in audio_files:
        print(f"   üîä {file}")
    
    # Reproduzir se solicitado
    if args.play and audio_files:
        for audio_file in audio_files:
            converter.play_audio(audio_file)

# ===== EXEMPLO DE USO INTERATIVO =====
def interactive_mode():
    """Modo interativo para facilitar o uso"""
    print("üéôÔ∏è Conversor Web para √Åudio - Modo Interativo")
    print("=" * 50)
    
    # URL
    url = input("üåê Digite a URL da p√°gina: ").strip()
    if not url:
        print("‚ùå URL obrigat√≥ria")
        return
    
    # Engine
    print("\nüîß Engines TTS dispon√≠veis:")
    print("1. Auto (recomendado)")
    print("2. Google TTS (online)")
    print("3. Edge TTS (online, melhor qualidade)")
    print("4. pyttsx3 (offline)")
    
    engine_choice = input("Escolha (1-4): ").strip()
    engine_map = {'1': 'auto', '2': 'gtts', '3': 'edge', '4': 'pyttsx3'}
    engine = engine_map.get(engine_choice, 'auto')
    
    # Configura√ß√µes
    speed = input("üèÉ Velocidade da fala (0.5-2.0, padr√£o 1.0): ").strip()
    try:
        speed = float(speed) if speed else 1.0
    except ValueError:
        speed = 1.0
    
    # Converter
    config = AudioConfig(speed=speed)
    converter = WebToAudioConverter(config)
    
    print(f"\nüöÄ Convertendo {url}...")
    audio_files = converter.convert_url_to_audio(url, engine=engine)
    
    if audio_files:
        print(f"\n‚úÖ Sucesso! {len(audio_files)} arquivos gerados:")
        for file in audio_files:
            print(f"   üîä {file}")
        
        if input("\nüîä Reproduzir agora? (s/N): ").lower().startswith('s'):
            for audio_file in audio_files:
                converter.play_audio(audio_file)
    else:
        print("‚ùå Falha na convers√£o")

if __name__ == "__main__":
    if len(sys.argv) == 1:
        # Modo interativo se n√£o houver argumentos
        interactive_mode()
    else:
        # Modo linha de comando
        main()
